## JPA Lock

    Lock을 하는 이유는, 트랜잭션의 격리 수준을 선택하기 위함이다.
    격리 수준과 동시성 사이에서 저울질을 잘 해야한다.

    JPA에서 제공하는 Lock에는 2가지 종류가 있다.
    
    1. 낙관적 Lock (어플리케이션 레벨)
    2. 비관적 Lock (데이터베이스 레벨)

    [참고]
    기본적으로 JPA에서는 Read-commited 격리수준과 Optimistic Lock 을 권장한다.
    
    [참고]
    MySQL은 디폴트로 repeatable-read
    Oracle은 디폴트로 read-commited 를 사용한다.

    [참고]
    DB 자체의 트랜잭션 격리 수준과, @Transactional 붙인 어플리케이션 단에서의 트랜잭션은 다른 것이다.
    어플리케이션단에서의 트랜잭션은 DB Connection Pool을 가지냐 마냐의 차이일 뿐이다ㅏ.

    [중요]
    결국 JPA의 낙관적 Lock과 비관적 Lock 의 가장 큰 차이점은
    
    낙관적 Lock의 경우 누가 먼저 commit을 했는지가 중요하고,
    -> commit시점에서 버전체크를 해서, 누가 먼저 수정했다면 rollback하기 때문에
    -> 여기에 LockMode.OPTIMISTIC 을 걸면, Read시에도 commit시 문제가 발생하기 때문에 Read도중에 버전 업데이트가 되더라도
    에러를 터뜨려 이를 방지할 수 있다.

    비관적 Lock의 경우 누가 먼저 Lock을 획득했는지가 중요하다.
    -> Lock 걸린 상태면 다른 트랜잭션에서 commit을 쏘는 순간 해당 트랜잭션이 실패해버리기 때문에

    알아보자.

#### 낙관적 Lock (OPTIMISTIC_LOCK)

    낙관적 락은 트랜잭션 대부분에서 충돌이 발생하지 않는다고 가정하는 Lock 방법이다.
    데이터베이스가 제공하는 Lock 기능을 사용하는 것이 아니라, JPA에서 제공하는 버전 관리 기능을 사용한다.

    즉 DB가 아닌 애플리케이션단에서 Lock을 거는 기능이다.

    트랜잭션이 커밋되기 전까지는 트랜잭션의 충돌을 알 수 없다.

#### 비관적 Lock (PESSIMISTIC_LOCK)

    비관적 락은 트랜잭션의 충돌이 발생한다고 가정하고 우선 DB에 Lock을 거는 방법이다.
    데이터베이스가 제공하는 Lock 기능을 사용한다.

    주로 PESSIMISTIC_WRITE 를 사용한다.

    select for update (수정할거니까 건드리지마) 기능이 있다.

---

#### 두 번의 갱신 분실 문제

    A와 B가 동시에 같은 글을 수정한다.
    A가 먼저 수정해서 commit을 했는데, B가 이후에 commit을 했다.

    결과로 B가 커밋한 내용만 남고 A가 commit한 내용은 사라져버렸다.
    이를 두 번의 갱신 분실 문제라고 한다.

    이것은 데이터베이스 트랜잭션의 범위를 벗어나는 문제이다.

    이를 해결하는 방법에는 3가지 전략이 있다.

    1. 마지막 커밋만 인정
    2. 첫 커밋만 인정
    3. 충돌내용 병합

    기본적으로는 마지막 커밋이 인정된다.
    JPA에서 제공하는 버전관리를 사용하면 첫 커밋만 인정을 구현할 수 있다.