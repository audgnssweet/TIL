## 트랜잭션의 격리 수준과 문제점

    트랜잭션간 격리 수준을 완벽하게 보장하려면, 거의 트랜잭션을 직렬화 해야한다.
    하지만 트랜잭션을 직렬화하면 동시성이 매우 떨어진다.

    그래서 트랜잭션 격리 수준을 4단계로 나눈다.

#### 트랜잭션의 격리 수준

    1. READ UNCOMMITED

    아직 커밋되지 않은, 즉 트랜잭션 중간에 수정된 정보도 다른 트랜잭션에서 읽을 수 있도록 한다.

    2. READ COMMITED

    커밋된 정보만을 다른 트랜잭션에서 읽을 수 있도록 한다.

    3. REPEATABLE READ

    한번 조회한 데이터를 반복조회 해도, 같은 데이터가 조회됨을 보장한다.
    (읽기중 다른 트랜잭션이 데이터 수정이 불가능하다)

    4. SERIALIZABLE

    트랜잭션을 거의 순서대로 실행한다. 동시성이 매우 떨어진다.

#### 트랜잭션의 동시성으로 발생할 수 있는 문제점

    1. DIRTY READ

    격리 수준 중 1단계 READ UNCOMMITED 까지에서 발생할 수 있는 문제이다.
    
    A가 데이터를 수정하고 있는데 (커밋되지 않은 상태) B가 수정중인 데이터를 읽어서 사용했다.
    그런데 트랜잭션 A 도중 문제가 생겨 Rollback이 된다면,
    B는 의미없는 데이터로 일처리를 한 것이 된다. 데이터 정합성(모순되지 않음)에 심각한 문제가 생긴다.
    이를 DIRTY READ라 한다.

    2. NON-REPEATABLE-READ

    격리 수준 중 2단계 READ COMMITED 까지에서 발생할 수 있는 문제이다.
    
    A가 한 트랜잭션 내에서 동일한 데이터를 2번 읽는다.
    첫 번째 읽고, 두 번째 읽기 직전에 B가 해당 데이터를 수정해서 커밋했다.
    그럼 A는 한 트랜잭션 내에서 동일한 데이터를 2번 읽었지만 내용은 달라졌다.
    이를 NON-REPEATABLE-READ 라 한다.

    3. PHANTOM READ

    격리 수준 중 3단계 REPEATABLE READ 까지에서 발생할 수 있는 문제이다.

    A가 한 트랜잭션 내에서 만원 이하의 상품을 두번 조회한다.
    첫 번째 조회한 이후에 두 번째 조회시에도, 중간에 다른 트랜잭션이 데이터를 변경할 수 없기에
    조회된 데이터가 변경되지는 않는다.
    그러나 두 번째 조회 전에 만원 이하의 상품이 한개 더 추가된다면 이 상품은 관리대상이 아니기에
    두 번째 읽을 때 데이터가 한개 추가된다
    이를 PHANTOM READ라 한다.